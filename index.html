import React, { useState, useEffect, useRef } from 'react';
import { Brain, RotateCcw, Zap, User, Trophy } from 'lucide-react';

// --- C·∫§U H√åNH & H·∫∞NG S·ªê ---
const SUITS = ['spades', 'clubs', 'diamonds', 'hearts'];
// Rank index: 3=0, 4=1, ..., A=11, 2=12. 3 B√≠ch c√≥ value = 0 (rank 0, suit 0)
const RANKS = ['3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
const SUIT_SYMBOLS = { spades: '‚ô†', clubs: '‚ô£', diamonds: '‚ô¶', hearts: '‚ô•' };

// Gi√° tr·ªã tuy·ªát ƒë·ªëi c·ªßa l√° b√†i
const getCardValue = (rankIdx, suitIdx) => rankIdx * 4 + suitIdx;

// --- LOGIC X·ª¨ L√ù B·ªò B√ÄI (CORE) ---

const createDeck = () => {
  const deck = [];
  RANKS.forEach((rank, rIdx) => {
    SUITS.forEach((suit, sIdx) => {
      deck.push({
        id: `${rank}-${suit}`,
        rank,
        suit,
        rankIdx: rIdx,
        suitIdx: sIdx,
        value: getCardValue(rIdx, sIdx),
        isSelected: false
      });
    });
  });
  return deck;
};

// H√†m x√°o tr·ªôn ng·∫´u nhi√™n (Fisher-Yates shuffle algorithm)
const shuffleDeck = (deck) => [...deck].sort(() => Math.random() - 0.5);

// Helper: Ki·ªÉm tra li√™n ti·∫øp rank index
const isConsecutive = (rankIndices) => {
  for (let i = 0; i < rankIndices.length - 1; i++) {
    if (rankIndices[i + 1] !== rankIndices[i] + 1) return false;
  }
  return true;
};

// H√†m quan tr·ªçng: X√°c ƒë·ªãnh lo·∫°i b√†i ng∆∞·ªùi ch∆°i ch·ªçn
const getCombinationType = (cards) => {
  if (!cards || cards.length === 0) return null;
  
  const sorted = [...cards].sort((a, b) => a.value - b.value);
  const len = sorted.length;
  const maxCard = sorted[len - 1]; 

  if (len === 1) return { type: 'single', value: maxCard.value, len: 1, highest: maxCard };

  const uniqueRanks = Array.from(new Set(sorted.map(c => c.rankIdx)));
  
  // C√°c b·ªô ƒë·ªìng h·∫°ng (ƒê√¥i, Ba, T·ª© qu√Ω)
  if (uniqueRanks.length === 1) {
    if (len === 2) return { type: 'pair', value: maxCard.value, len: 2, highest: maxCard };
    if (len === 3) return { type: 'triple', value: maxCard.value, len: 3, highest: maxCard };
    if (len === 4) return { type: 'four', value: maxCard.value, len: 4, highest: maxCard };
    return null;
  }

  // S·∫¢NH (Straight) - 3 l√° tr·ªü l√™n, li√™n ti·∫øp, KH√îNG CH·ª®A 2 (Heo)
  if (len >= 3) {
    if (!sorted.some(c => c.rankIdx === 12)) {
        // Ph·∫£i l√† c√°c rank li√™n ti·∫øp v√† s·ªë l∆∞·ª£ng card ƒë√∫ng b·∫±ng s·ªë rank duy nh·∫•t
        if (uniqueRanks.length === len && isConsecutive(uniqueRanks)) {
            return { type: 'straight', value: maxCard.value, len: len, highest: maxCard };
        }
    }
  }

  // ƒê√îI TH√îNG (Pine Pairs)
  if (len >= 6 && len % 2 === 0 && !sorted.some(c => c.rankIdx === 12)) {
      const numPairs = len / 2;
      const rankCounts = {};
      sorted.forEach(c => rankCounts[c.rankIdx] = (rankCounts[c.rankIdx] || 0) + 1);
      
      // Ki·ªÉm tra t·∫•t c·∫£ ph·∫£i l√† ƒë√¥i (ƒë√∫ng 2 l√°)
      if (Object.values(rankCounts).some(count => count !== 2)) return null;

      // L·∫•y rank c·ªßa c√°c ƒë√¥i
      const pairRanks = uniqueRanks.filter(r => rankCounts[r] === 2).sort((a, b) => a - b);
      
      // Ki·ªÉm tra li√™n ti·∫øp rank c·ªßa c√°c ƒë√¥i
      if (pairRanks.length === numPairs && isConsecutive(pairRanks)) {
          if (numPairs === 3) return { type: '3-pine', value: maxCard.value, len: 6, highest: maxCard };
          if (numPairs === 4) return { type: '4-pine', value: maxCard.value, len: 8, highest: maxCard };
      }
  }

  return null; // Kh√¥ng h·ª£p l·ªá
};

// Logic so b√†i: B√†i A c√≥ ch·∫∑t ƒë∆∞·ª£c B√†i B (tr√™n b√†n) kh√¥ng?
const canBeat = (myCards, boardState) => {
    const myComb = getCombinationType(myCards);
    if (!myComb) return false; 

    if (!boardState || boardState.cards.length === 0) return true;

    const boardComb = getCombinationType(boardState.cards);
    if (!boardComb) return false; 

    // C√ôNG LO·∫†I
    if (myComb.type === boardComb.type && myComb.len === boardComb.len) {
        return myComb.value > boardComb.value;
    }

    // LU·∫¨T CH·∫∂T
    const boardIsPig = boardComb.type === 'single' && boardComb.highest.rankIdx === 12; 
    const boardIsPigPair = boardComb.type === 'pair' && boardComb.highest.rankIdx === 12; 

    // 3 ƒê√¥i th√¥ng ch·∫∑t 1 Heo
    if (myComb.type === '3-pine' && boardIsPig) return true;

    // T·ª© qu√Ω ch·∫∑t Heo, ƒê√¥i Heo, 3 ƒê√¥i th√¥ng
    if (myComb.type === 'four') {
        if (boardIsPig || boardIsPigPair || boardComb.type === '3-pine') return true;
    }

    // 4 ƒê√¥i th√¥ng ch·∫∑t Heo, ƒê√¥i Heo, 3 ƒê√¥i th√¥ng, T·ª© qu√Ω
    if (myComb.type === '4-pine') {
         if (boardIsPig || boardIsPigPair || boardComb.type === '3-pine' || boardComb.type === 'four') return true;
    }

    return false;
};

// --- COMPONENT CH√çNH ---

export default function TienLenGeminiPro() {
  const [playerHand, setPlayerHand] = useState([]);
  const [aiHand, setAiHand] = useState([]);
  const [board, setBoard] = useState({ cards: [], owner: null });
  const [turn, setTurn] = useState(null); 
  const [gameStatus, setGameStatus] = useState('start'); 
  const [winner, setWinner] = useState(null);
  const [logs, setLogs] = useState([]);
  const [lastPass, setLastPass] = useState(null); 

  const logRef = useRef(null);

  useEffect(() => {
     if (logRef.current) logRef.current.scrollTop = logRef.current.scrollHeight;
  }, [logs]);

  // --- H√ÄNH ƒê·ªòNG GAME ---

  const startGame = () => {
    // 1. Reset tr·∫°ng th√°i v√† chuy·ªÉn sang 'dealing'
    setGameStatus('dealing');
    setPlayerHand([]); 
    setAiHand([]);
    setBoard({ cards: [], owner: null });
    setWinner(null);
    setLogs([{ type: 'sys', text: "ƒê√£ x√°o tr·ªôn b·ªô b√†i. B·∫Øt ƒë·∫ßu chia b√†i..." }]);
    setLastPass(null);

    // 2. M√¥ ph·ªèng ƒë·ªô tr·ªÖ khi chia b√†i (1.5 gi√¢y)
    setTimeout(() => {
        // Thu·∫≠t to√°n chia b√†i: X√°o tr·ªôn v√† chia 13 l√° cho m·ªói ng∆∞·ªùi
        const newDeck = shuffleDeck(createDeck());
        const pHand = newDeck.slice(0, 13).sort((a, b) => a.value - b.value); 
        const aHand = newDeck.slice(13, 26).sort((a, b) => a.value - b.value); 

        setPlayerHand(pHand);
        setAiHand(aHand);
        
        // X√°c ƒë·ªãnh ng∆∞·ªùi ƒëi tr∆∞·ªõc (ng∆∞·ªùi c√≥ 3 B√≠ch)
        const pHas3Spades = pHand.some(c => c.value === 0);
        const starter = pHas3Spades ? 'player' : 'ai';
        setTurn(starter);
        
        // 3. Chuy·ªÉn sang tr·∫°ng th√°i 'playing'
        setGameStatus('playing');
        
        if (starter === 'ai') {
            addLog('sys', 'AI ƒëi tr∆∞·ªõc (c√≥ 3‚ô†)');
        } else {
            addLog('sys', 'B·∫°n ƒëi tr∆∞·ªõc (c√≥ 3‚ô†)');
        }
    }, 1500); 
  };

  const addLog = (type, text) => {
      setLogs(prev => [...prev, { type, text, time: new Date().toLocaleTimeString().slice(0,5) }]);
  };

  const getCombName = (comb) => {
      if (!comb) return 'B·ªô kh√¥ng h·ª£p l·ªá';
      const rank = comb.highest.rank;
      const suit = SUIT_SYMBOLS[comb.highest.suit];
      switch (comb.type) {
          case 'single': return `L·∫ª ${rank}${suit}`;
          case 'pair': return `ƒê√¥i ${rank}`;
          case 'triple': return `Ba c√¢y ${rank}`;
          case 'four': return `T·ª© qu√Ω ${rank}`;
          case 'straight': return `S·∫£nh ${comb.len} c√¢y (t·ªõi ${rank})`;
          case '3-pine': return `3 ƒê√¥i th√¥ng (t·ªõi ${rank})`;
          case '4-pine': return `4 ƒê√¥i th√¥ng (t·ªõi ${rank})`;
          default: return 'B·ªô B√†i';
      }
  };

  // --- PLAYER ACTIONS ---

  const handleCardClick = (id) => {
      if (gameStatus !== 'playing') return;
      setPlayerHand(prev => prev.map(c => c.id === id ? { ...c, isSelected: !c.isSelected } : c));
  };

  const onPlayerPlay = () => {
      const selected = playerHand.filter(c => c.isSelected);
      if (selected.length === 0) return;
      if (turn !== 'player') return;
      
      let currentBoard = board;
      // N·∫øu AI b·ªè l∆∞·ª£t v√† v√≤ng b√†i thu·ªôc v·ªÅ m√¨nh, reset board
      if (lastPass === 'ai' && board.owner === 'player') {
          currentBoard = { cards: [], owner: null }; 
      }
      
      const isAbsoluteFirstTurn = board.cards.length === 0 && turn === 'player';
      const hasThreeSpades = playerHand.some(c => c.value === 0);
      
      // Ki·ªÉm tra lu·∫≠t 3 B√≠ch
      if (isAbsoluteFirstTurn && hasThreeSpades && !selected.some(c => c.value === 0)) {
          console.error("L∆∞·ª£t ƒëi ƒë·∫ßu ti√™n, b·∫°n ph·∫£i ƒë√°nh qu√¢n 3 B√≠ch!");
          return;
      }

      if (!canBeat(selected, currentBoard)) {
          const myType = getCombinationType(selected);
          if (!myType) {
              console.error("B·ªô b√†i kh√¥ng h·ª£p l·ªá (Kh√¥ng ph·∫£i l·∫ª, ƒë√¥i, s·∫£nh, hay h√†ng).");
          } else {
              console.error("B√†i kh√¥ng ch·∫∑t ƒë∆∞·ª£c b√†i tr√™n b√†n!");
          }
          return;
      }

      const newHand = playerHand.filter(c => !c.isSelected);
      setPlayerHand(newHand.map(c => ({...c, isSelected: false}))); 
      setBoard({ cards: selected, owner: 'player' });
      setTurn('ai');
      setLastPass(null); 
      
      const comb = getCombinationType(selected);
      addLog('player', `B·∫°n ƒë√°nh: ${getCombName(comb)}`);

      if (newHand.length === 0) endGame('player');
  };

  const onPlayerPass = () => {
      if (turn !== 'player') return;
      if (board.cards.length === 0 || (board.owner === 'player' && lastPass === 'ai')) {
          console.error("B·∫°n ƒëang c·∫ßm v√≤ng, kh√¥ng th·ªÉ b·ªè l∆∞·ª£t!");
          return;
      }
      addLog('player', 'B·∫°n b·ªè l∆∞·ª£t');
      setLastPass('player');
      setTurn('ai');
  };

  // --- AI LOGIC (GEMINI BRAIN) ---

  useEffect(() => {
      if (turn === 'ai' && gameStatus === 'playing') {
          const timer = setTimeout(() => runAITurn(), 1500); 
          return () => clearTimeout(timer);
      }
  }, [turn, gameStatus, aiHand, board, lastPass]); // eslint-disable-line

  const runAITurn = () => {
      let move = null;
      let reason = "";

      const aiPlayable = analyzeHand(aiHand);
      
      // Danh s√°ch c√°c b·ªô b√†i AI c√≥ th·ªÉ ƒë√°nh, ∆∞u ti√™n t·ª´ m·∫°nh/d√†i nh·∫•t ƒë·∫øn y·∫øu nh·∫•t.
      let allCombos = [
          ...aiPlayable['4-pine'],
          ...aiPlayable['3-pine'],
          ...aiPlayable.straights,
          ...aiPlayable.triples,
          ...aiPlayable.pairs,
          ...aiPlayable.singles,
          ...aiPlayable.fours // T·ª© qu√Ω gi·ªØ ri√™ng, ch·ªâ d√πng ƒë·ªÉ ch·∫∑t ho·∫∑c ƒëi t·ª± do cu·ªëi c√πng
      ];
      
      // S·∫Øp x·∫øp: ∆Øu ti√™n b·ªô d√†i h∆°n, sau ƒë√≥ l√† b·ªô c√≥ gi√° tr·ªã nh·ªè nh·∫•t (ƒë·ªÉ t·ªëng b√†i r√°c)
      allCombos.sort((a, b) => {
          if (b.len !== a.len) return b.len - a.len; 
          return a.value - b.value; 
      });

      const isAbsoluteFirstTurn = board.cards.length === 0 && aiHand.some(c => c.value === 0); 
      let isFreeTurn = board.cards.length === 0 || (lastPass === 'player' && board.owner === 'ai'); 
      
      // -----------------------------------------------------------
      // I. X·ª≠ l√Ω l∆∞·ª£t ƒëi ƒë·∫ßu ti√™n c·ªßa V√ÅN B√ÄI (B·∫ÆT BU·ªòC ƒê√ÅNH 3 B√çCH)
      // -----------------------------------------------------------
      if (isAbsoluteFirstTurn) { 
          const threeSpades = aiHand.find(c => c.value === 0);

          // 1. T√¨m b·ªô b√†i t·ªët nh·∫•t c√≥ ch·ª©a 3‚ô†
          const startingCombos = allCombos
              .filter(c => c.cards.some(card => card.value === 0))
              .sort((a, b) => {
                  if (b.cards.length !== a.cards.length) return b.cards.length - a.cards.length; 
                  return a.value - b.value; // ∆Øu ti√™n b·ªô nh·ªè h∆°n (r√°c h∆°n)
              });

          if (startingCombos.length > 0) {
              move = startingCombos[0].cards;
              reason = `M·ªü ƒë·∫ßu b·∫Øt bu·ªôc: ƒê√°nh 3‚ô† trong b·ªô ${startingCombos[0].type} t·ªët nh·∫•t.`;
          } else {
              // 2. N·∫øu kh√¥ng c√≥ b·ªô n√†o, ƒë√°nh 3‚ô† l·∫ª
              move = [threeSpades];
              reason = "M·ªü ƒë·∫ßu b·∫Øt bu·ªôc: ƒê√°nh qu√¢n 3‚ô† l·∫ª.";
          }
      // -----------------------------------------------------------
      // II. X·ª≠ l√Ω c√°c l∆∞·ª£t c·∫ßm v√≤ng sau (ƒê√°nh b·ªô m·∫°nh nh·∫•t/d√†i nh·∫•t c√≥ th·ªÉ)
      // -----------------------------------------------------------
      } else if (isFreeTurn) { 
          // Ch·ªâ c·∫ßn l·∫•y b·ªô ƒë·∫ßu ti√™n ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp (d√†i nh·∫•t, nh·ªè nh·∫•t)
          const bestFreeMove = allCombos[0];
          
          if (bestFreeMove) {
              move = bestFreeMove.cards;
              reason = `C·∫ßm v√≤ng: ƒê√°nh b·ªô ${bestFreeMove.type} d√†i/nh·ªè nh·∫•t.`;
          } else {
              // Fallback: n·∫øu kh√¥ng c√≥ b·ªô n√†o h·ª£p l·ªá (r·∫•t hi·∫øm)
              move = [aiHand[0]];
              reason = "C·∫ßm v√≤ng: ƒê√°nh qu√¢n l·∫ª nh·ªè nh·∫•t (Fallback).";
          }
      // -----------------------------------------------------------
      // III. X·ª≠ l√Ω ch·∫∑t b√†i (Block opponent)
      // -----------------------------------------------------------
      } else {
          const boardComb = getCombinationType(board.cards);
          
          // 1. T√¨m b·ªô c√πng lo·∫°i l·ªõn h∆°n
          const candidates = allCombos.filter(c => canBeat(c.cards, board));
          if (candidates.length > 0) {
              // L·∫•y b·ªô nh·ªè nh·∫•t trong s·ªë c√°c b·ªô c√≥ th·ªÉ ch·∫∑t
              move = candidates[0].cards; 
              reason = `Ch·∫∑n ƒë·ªëi th·ªß b·∫±ng b·ªô ${getCombinationType(move).type} nh·ªè nh·∫•t.`;
          }
          
          // 2. Ki·ªÉm tra ch·∫∑t h√†ng (ch·∫∑t Heo, ƒê√¥i Heo, T·ª© Qu√Ω)
          if (!move) {
              // K·∫øt h·ª£p t·∫•t c·∫£ T·ª© qu√Ω v√† 4 ƒê√¥i th√¥ng (∆∞u ti√™n 4 ƒë√¥i th√¥ng, r·ªìi t·ª© qu√Ω nh·ªè)
              const cuttingCombos = [...aiPlayable['4-pine'], ...aiPlayable.fours].sort((a,b) => a.value - b.value); 
              
              for (const combo of cuttingCombos) {
                  if (canBeat(combo.cards, board)) {
                      move = combo.cards;
                      reason = `${combo.type === 'four' ? 'T·ª© qu√Ω' : '4 ƒê√¥i th√¥ng'} ch·∫∑t b√†i tr√™n b√†n!`;
                      break;
                  }
              }
          }
          // Th√™m 3 ƒê√¥i th√¥ng ch·∫∑t Heo
          if (!move && boardComb.type === 'single' && boardComb.highest.rankIdx === 12) {
              const pine3 = aiPlayable['3-pine'].sort((a,b) => a.value - b.value);
              if(pine3.length > 0) {
                  move = pine3[0].cards;
                  reason = "3 ƒê√¥i th√¥ng ch·∫∑t Heo!";
              }
          }
      }

      // Th·ª±c thi
      if (move) {
          const comb = getCombinationType(move);
          setBoard({ cards: move, owner: 'ai' });
          const newHand = aiHand.filter(c => !move.includes(c));
          setAiHand(newHand);
          setTurn('player');
          setLastPass(null);
          addLog('ai', `AI ƒë√°nh: ${getCombName(comb)} (${reason})`);
          if (newHand.length === 0) endGame('ai');
      } else {
          setLastPass('ai');
          setTurn('player');
          addLog('ai', 'AI b·ªè l∆∞·ª£t. B√†i kh√¥ng ƒë·ªß m·∫°nh ƒë·ªÉ ch·∫∑n.');
      }
  };

  // Helper AI: Ph√¢n lo·∫°i b√†i trong tay (ƒê√£ ch·ªânh s·ª≠a ƒë·ªÉ l·∫•y ƒë·ªß c√°c b·ªô)
  const analyzeHand = (hand) => {
      const rankCounts = {};
      hand.forEach(c => rankCounts[c.rankIdx] = (rankCounts[c.rankIdx] || 0) + 1);

      const singles = [];
      const pairs = [];
      const triples = [];
      const fours = [];
      const straights = [];
      const pine3 = [];
      const pine4 = [];

      // 1. ƒê·ªìng h·∫°ng (Singles, Pairs, Triples, Fours)
      const uniqueRanks = Object.keys(rankCounts).map(Number).sort((a, b) => a - b);
      uniqueRanks.forEach(r => {
          const cards = hand.filter(c => c.rankIdx === r).sort((a, b) => a.value - b.value);
          if (rankCounts[r] === 1) singles.push({ cards, type: 'single', len: 1, value: cards[0].value });
          if (rankCounts[r] === 2) pairs.push({ cards, type: 'pair', len: 2, value: cards[1].value });
          if (rankCounts[r] === 3) triples.push({ cards, type: 'triple', len: 3, value: cards[2].value });
          if (rankCounts[r] === 4) fours.push({ cards, type: 'four', len: 4, value: cards[3].value });
      });

      // 2. S·∫£nh (Straights)
      const nonPigRanks = uniqueRanks.filter(r => r < 12).sort((a, b) => a - b);
      for (let length = 3; length <= nonPigRanks.length; length++) {
          for (let i = 0; i <= nonPigRanks.length - length; i++) {
              const currentRanks = nonPigRanks.slice(i, i + length);
              if (isConsecutive(currentRanks)) {
                  // L·∫•y c√°c l√° b√†i t∆∞∆°ng ·ª©ng
                  const sCards = hand.filter(c => currentRanks.includes(c.rankIdx)).sort((a, b) => a.value - b.value);
                  // ƒê·∫£m b·∫£o kh√¥ng b·ªã tr√πng l·∫∑p b·ªô (v√≠ d·ª• 3-4-5 v√† 3-4-5-6)
                  if (sCards.length === currentRanks.length) {
                       const isSubset = straights.some(s => s.cards.length >= sCards.length && sCards.every(sc => s.cards.some(c => c.id === sc.id)));
                       if (!isSubset) {
                           straights.push({ 
                              cards: sCards, 
                              type: 'straight', 
                              len: sCards.length, 
                              value: sCards[sCards.length - 1].value 
                          });
                      }
                  }
              }
          }
      }
      // Lo·∫°i b·ªè c√°c b·ªô s·∫£nh ng·∫Øn h∆°n ƒë√£ n·∫±m trong b·ªô s·∫£nh d√†i h∆°n
      const finalStraights = straights.filter(s1 => 
          !straights.some(s2 => s2.len > s1.len && s1.cards.every(c1 => s2.cards.some(c2 => c1.id === c2.id)))
      );
      finalStraights.sort((a, b) => b.len - a.len || a.value - b.value);

      // 3. ƒê√¥i th√¥ng (Pine Pairs)
      const sortedPairs = pairs.sort((a, b) => a.cards[0].rankIdx - b.cards[0].rankIdx);

      // 3-pine (3 ƒë√¥i th√¥ng)
      for (let i = 0; i <= sortedPairs.length - 3; i++) {
          const ranks = [sortedPairs[i], sortedPairs[i+1], sortedPairs[i+2]].map(p => p.cards[0].rankIdx);
          if (isConsecutive(ranks) && ranks[2] < 12) { // Ranks[2] l√† rank cao nh·∫•t
              pine3.push({ 
                  cards: [...sortedPairs[i].cards, ...sortedPairs[i+1].cards, ...sortedPairs[i+2].cards], 
                  type: '3-pine', 
                  len: 6,
                  value: sortedPairs[i+2].cards[1].value 
              });
          }
      }

      // 4-pine (4 ƒë√¥i th√¥ng)
      for (let i = 0; i <= sortedPairs.length - 4; i++) {
          const ranks = [sortedPairs[i], sortedPairs[i+1], sortedPairs[i+2], sortedPairs[i+3]].map(p => p.cards[0].rankIdx);
          if (isConsecutive(ranks) && ranks[3] < 12) { 
              pine4.push({ 
                  cards: [...sortedPairs[i].cards, ...sortedPairs[i+1].cards, ...sortedPairs[i+2].cards, ...sortedPairs[i+3].cards], 
                  type: '4-pine', 
                  len: 8,
                  value: sortedPairs[i+3].cards[1].value
              });
          }
      }
      
      // Sort pine pairs by value (smallest first)
      pine3.sort((a,b) => a.value - b.value);
      pine4.sort((a,b) => a.value - b.value);

      return { singles, pairs, triples, fours, straights: finalStraights, '3-pine': pine3, '4-pine': pine4 };
  };


  const endGame = (who) => {
      setGameStatus('end');
      setWinner(who);
  };

  // --- RENDER ---
  
  return (
    <div className="flex flex-col h-screen bg-green-900 text-white font-sans overflow-hidden">
        
        {/* TOP BAR: AI HAND & INFO */}
        <div className="flex-none p-2 bg-green-950/50 flex justify-between items-start z-10">
            <div className="flex flex-col items-start w-1/3">
                 <div className="flex items-center gap-2 mb-2">
                    <div className="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center border-2 border-white shadow-lg">
                        <Brain size={16} />
                    </div>
                    <div>
                        <div className="font-bold text-xs">Gemini AI</div>
                        {/* Ch·ªâ hi·ªÉn th·ªã s·ªë l√° b√†i khi ƒëang ch∆°i */}
                        <div className="text-xs text-green-300">
                             {gameStatus === 'playing' ? `${aiHand.length} l√°` : 'S·∫µn s√†ng'}
                        </div>
                    </div>
                 </div>
                 {/* Mini Hand View for AI (Hidden cards) */}
                 <div className="flex pl-4 scale-75 origin-top-left -space-x-4">
                     {aiHand.map((c, i) => (
                         <div key={i} className="w-10 h-14 bg-blue-900 rounded border border-white/30 shadow-md" />
                     ))}
                 </div>
            </div>

            {/* AI LOGS */}
            <div className="w-2/3 h-24 overflow-y-auto text-xs bg-black/40 rounded p-2 font-mono custom-scrollbar" ref={logRef}>
                {logs.map((l, i) => (
                    <div key={i} className={`mb-1 ${
                        l.type === 'ai' ? 'text-yellow-300' : 
                        l.type === 'player' ? 'text-green-300' : 'text-gray-400'
                    }`}>
                        <span className="opacity-50">[{l.time}]</span> {l.text}
                    </div>
                ))}
            </div>
        </div>

        {/* MIDDLE: BOARD AREA */}
        <div className="flex-1 relative flex items-center justify-center pt-8 pb-10"> 
            {/* Center Board */}
            <div className="relative w-full max-w-2xl h-48 flex items-center justify-center">
                {board.cards.length > 0 ? (
                    <div className="relative">
                         <div className="text-center text-xs uppercase font-bold tracking-widest text-yellow-500/80 mb-4 animate-pulse">
                             {board.owner === 'ai' ? 'AI v·ª´a ƒë√°nh' : 'B·∫°n v·ª´a ƒë√°nh'}
                         </div>
                         <div className="flex justify-center -space-x-8 sm:-space-x-12">
                            {board.cards.map((c, i) => (
                                <CardView key={c.id} card={c} isPlayed={true} style={{ transform: `rotate(${(i - board.cards.length/2) * 5}deg) translateY(${Math.abs(i - board.cards.length/2) * -5}px)` }} />
                            ))}
                         </div>
                    </div>
                ) : (
                    <div className="text-green-500/30 font-bold text-xl uppercase tracking-widest">
                        {gameStatus === 'dealing' ? 'ƒêANG CHIA B√ÄI...' : 
                         gameStatus === 'start' ? 'S·∫¥N S√ÄNG CH∆†I' : 'B√ÄN TR·ªêNG'}
                    </div>
                )}
            </div>

            {/* Turn Indicator */}
            {gameStatus === 'playing' && (
                <div className={`absolute top-0 left-1/2 transform -translate-x-1/2 px-4 py-1 rounded-full text-sm font-bold shadow-lg flex items-center gap-2 transition-all ${
                    turn === 'player' ? 'bg-yellow-500 text-black scale-110' : 'bg-gray-800 text-gray-400'
                }`}>
                    {turn === 'player' ? <><User size={14}/> L∆∞·ª£t c·ªßa b·∫°n</> : <><Brain size={14}/> AI ƒëang nghƒ©...</>}
                </div>
            )}
            
            {/* GAME OVER MODAL */}
            {gameStatus === 'end' && (
                <div className="absolute inset-0 z-50 bg-black/80 flex items-center justify-center p-4">
                    <div className="bg-white text-gray-900 rounded-xl p-6 max-w-sm w-full text-center shadow-2xl animate-bounce-in">
                        <div className="text-5xl mb-4">{winner === 'player' ? 'üèÜ' : 'ü§ñ'}</div>
                        <h2 className={`text-2xl font-bold mb-2 ${winner === 'player' ? 'text-green-600' : 'text-red-600'}`}>
                            {winner === 'player' ? 'B·∫†N TH·∫ÆNG R·ªíI!' : 'AI TH·∫ÆNG!'}
                        </h2>
                        <button onClick={startGame} className="w-full bg-blue-600 text-white font-bold py-3 rounded-lg shadow-lg hover:bg-blue-500 flex items-center justify-center gap-2 mt-4">
                            <RotateCcw size={18}/> Ch∆°i L·∫°i
                        </button>
                    </div>
                </div>
            )}
        </div>

        {/* BOTTOM: PLAYER CONTROLS & HAND (Z-index cao ƒë·ªÉ kh√¥ng b·ªã che) */}
        <div className="flex-none bg-gradient-to-t from-black/90 to-transparent pb-4 pt-10 relative z-20"> 
            {/* Controls */}
            {gameStatus === 'playing' && (
                <div className="flex justify-center gap-4 mb-4">
                    <button 
                        onClick={onPlayerPass}
                        disabled={turn !== 'player'}
                        className={`px-6 py-3 rounded-full font-bold text-sm shadow-lg backdrop-blur-sm border transition-all transform active:scale-95 ${
                            turn === 'player' ? 'bg-red-500/20 border-red-500 text-red-100 hover:bg-red-500 hover:text-white' : 'opacity-50 bg-gray-600 border-gray-500 cursor-not-allowed'
                        }`}
                    >
                        B·ªè l∆∞·ª£t
                    </button>
                    <button 
                        onClick={onPlayerPlay}
                        disabled={turn !== 'player'}
                        className={`px-8 py-3 rounded-full font-bold text-sm shadow-lg backdrop-blur-sm border transition-all transform active:scale-95 flex items-center gap-2 ${
                            turn === 'player' ? 'bg-yellow-500 text-black border-yellow-400 hover:scale-105' : 'opacity-50 bg-gray-600 border-gray-500 cursor-not-allowed'
                        }`}
                    >
                        <Zap size={16} fill="black" /> ƒê√ÅNH
                    </button>
                </div>
            )}
            
            {/* N√∫t B·∫Øt ƒë·∫ßu/Ch∆°i L·∫°i (ch·ªâ hi·ªÉn th·ªã khi kh√¥ng ph·∫£i tr·∫°ng th√°i 'playing' ho·∫∑c 'end') */}
            {gameStatus !== 'playing' && gameStatus !== 'end' && (
                <div className="flex justify-center mb-8">
                    <button 
                        onClick={startGame} 
                        disabled={gameStatus === 'dealing'} // V√¥ hi·ªáu h√≥a n√∫t khi ƒëang chia b√†i
                        className={`px-8 py-3 rounded-full font-bold shadow-lg flex items-center gap-2 transition-all 
                            ${gameStatus === 'dealing' 
                                ? 'bg-gray-500 text-gray-300 cursor-not-allowed' 
                                : 'bg-blue-600 text-white hover:bg-blue-500 animate-pulse'
                            }`}
                    >
                        {gameStatus === 'dealing' 
                            ? 'ƒêang Chia B√†i...' 
                            : <><Trophy size={18}/> B·∫Øt ƒê·∫ßu V√°n M·ªõi</>
                        }
                    </button>
                </div>
            )}

            {/* Hand (Fan Style) */}
            <div className="relative h-40 sm:h-48 flex justify-center items-end px-2 overflow-hidden"> 
                {/* D√πng -space-x-16 (4rem overlap) cho mobile v√† gi·∫£m g√≥c xoay */}
                <div className="flex items-end -space-x-16 sm:-space-x-16 mb-2 px-8 overflow-visible"> 
                    {playerHand.map((c, i) => (
                        <div key={c.id} 
                             className="transform transition-all duration-200 hover:z-20 origin-bottom"
                             style={{ 
                                 zIndex: i,
                                 // G√≥c xoay 1.5deg ƒë·ªÉ thu h·∫πp ƒë·ªô xo√®
                                 transform: c.isSelected 
                                    ? `translateY(-30px) rotate(${(i - playerHand.length/2) * 1.5}deg)` 
                                    : `rotate(${(i - playerHand.length/2) * 1.5}deg)` 
                             }}
                        >
                            <CardView card={c} onClick={() => handleCardClick(c.id)} />
                        </div>
                    ))}
                </div>
            </div>
        </div>

        <style>{`
            .custom-scrollbar::-webkit-scrollbar { width: 4px; }
            .custom-scrollbar::-webkit-scrollbar-thumb { background: #4ade80; border-radius: 4px; }
        `}</style>
    </div>
  );
}

// --- SUB-COMPONENT: UI L√Å B√ÄI ---
const CardView = ({ card, onClick, isPlayed = false, style = {} }) => {
    const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
    return (
        <div 
            onClick={onClick}
            style={style}
            className={`
                relative bg-white rounded-lg shadow-xl cursor-pointer select-none border-2 border-gray-400
                flex flex-col justify-between p-1 sm:p-2
                ${isPlayed ? 'w-16 h-24 sm:w-20 sm:h-28' : 'w-20 h-28 sm:w-24 sm:h-36'} 
                transition-shadow hover:shadow-2xl hover:border-blue-500
                ${card.isSelected ? 'ring-4 ring-yellow-400 border-yellow-500 translate-y-[-10px]' : ''}
                ${isRed ? 'text-red-700' : 'text-gray-900'}
            `}
        >
            <div className={`text-md sm:text-lg font-bold leading-none`}>
                {card.rank}
                <div className="text-sm sm:text-base">{SUIT_SYMBOLS[card.suit]}</div>
            </div>
            
            <div className={`absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-3xl sm:text-5xl opacity-80`}>
                {SUIT_SYMBOLS[card.suit]}
            </div>

            <div className={`text-md sm:text-lg font-bold leading-none transform rotate-180 self-end`}>
                {card.rank}
                <div className="text-sm sm:text-base">{SUIT_SYMBOLS[card.suit]}</div>
            </div>
        </div>
    );
};

